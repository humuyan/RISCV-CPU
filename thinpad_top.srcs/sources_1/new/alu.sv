`default_nettype none
`timescale 1ns / 1ps
`include "alu.vh"

module alu(
    input wire[3:0]        op,
    input wire[31:0]       a,
    input wire[31:0]       b,
    output wire[31:0]      r,
    output wire[3:0]       flags
    );
        
    reg zf,cf,sf,vf;
    reg[31:0] result;
    
    assign flags = {zf,cf,sf,vf};
    assign r = result;
    
    always_comb begin
        zf = 0;
        cf = 0;
        sf = 0;
        vf = 0;
        case (op)
            `ADD: begin
                result = a + b;
                if (result < a)
                    cf = 1'b1;
                else
                    cf = 1'b0;
                if ((result[31] != a[31]) && (a[31] == b[31]))
                    vf = 1'b1;
                else
                    vf = 1'b0;
            end
            
            `SUB: begin
                result = a - b;
                if (result > a)
                    cf = 1'b1;
                else
                    cf = 1'b0;
                if ((result[31] != a[31]) && (a[31] == b[31]))
                    vf = 1'b1;
                else
                    vf = 1'b0;
            end
            `AND: result = a & b;
            `OR: result = a | b;
            `XOR: result = a ^ b;
            `NOT: result = ~a;
            `SLL: result = a << b;
            `SRL: result = a >> b;
            `SRA: result = $signed(a) >>> b;                
            `ROL: result = (a << b) | (a >> (32 - b)); 
            `CLZ: begin  // vivado will optimize this code in the synthesis phase
                casez(a)
                    32'b00000000000000000000000000000000: result = 32;
                    32'b00000000000000000000000000000001: result = 31;
                    32'b0000000000000000000000000000001?: result = 30;
                    32'b000000000000000000000000000001??: result = 29;
                    32'b00000000000000000000000000001???: result = 28;
                    32'b0000000000000000000000000001????: result = 27;
                    32'b000000000000000000000000001?????: result = 26;
                    32'b00000000000000000000000001??????: result = 25;
                    32'b0000000000000000000000001???????: result = 24;
                    32'b000000000000000000000001????????: result = 23;
                    32'b00000000000000000000001?????????: result = 22;
                    32'b0000000000000000000001??????????: result = 21;
                    32'b000000000000000000001???????????: result = 20;
                    32'b00000000000000000001????????????: result = 19;
                    32'b0000000000000000001?????????????: result = 18;
                    32'b000000000000000001??????????????: result = 17;
                    32'b00000000000000001???????????????: result = 16;
                    32'b0000000000000001????????????????: result = 15;
                    32'b000000000000001?????????????????: result = 14;
                    32'b00000000000001??????????????????: result = 13;
                    32'b0000000000001???????????????????: result = 12;
                    32'b000000000001????????????????????: result = 11;
                    32'b00000000001?????????????????????: result = 10;
                    32'b0000000001??????????????????????: result = 9;
                    32'b000000001???????????????????????: result = 8;
                    32'b00000001????????????????????????: result = 7;
                    32'b0000001?????????????????????????: result = 6;
                    32'b000001??????????????????????????: result = 5;
                    32'b00001???????????????????????????: result = 4;
                    32'b0001????????????????????????????: result = 3;
                    32'b001?????????????????????????????: result = 2;
                    32'b01??????????????????????????????: result = 1;
                    32'b1???????????????????????????????: result = 0;
                    default: result = 0;
                endcase
            end
            `PCNT: begin
                result = 0;
                foreach(a[idx]) begin  // comb
                    result += a[idx];
                end
            end
            `SBCLR: result = a & (~(1 << b[4:0]));
            `SLTU: result = {31'b0, (a < b)};
            default: result = 0;
        endcase
        
        zf = result == 0? 1'b1: 1'b0;
        if (result[31] == 1'b1) 
            sf = 1'b1;
        else
            sf = 1'b0;
    end

endmodule
